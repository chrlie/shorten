.. _introduction:

Introduction
============

Shorten is based around a :class:`dict`-like object called a `store`. 
Stores allow insertion, deletion and lookup of data through an interface similar to a Python :class:`dict`, the primary difference being that store `keys` 
are generated automatically by a `key generator` (or `keygen`).

The corresponding usage between a Python :class:`dict` and store is illustrated 
below:

==================================       ====================
store                                    dict
==================================       ====================
``key, token = store.insert(val)``       ``dict[key] = val``
``del store[token]``                     ``del dict[key]``
``key in store``                         ``key in dict``
``for key in iter(store)`` [#f1]_        ``for key in iter(dict)``
``store.has_token(token)``               no equivalent
``store.get_token(key)``                 no equivalent
``len(store)`` [#f1]_                    ``len(dict)``
==================================       ====================

.. [#f1] This functionality may be missing from some stores due to
         inefficiency or thread safety.

When data is inserted into a store a :class:`Pair <Pair>` is returned. Pairs 
are tuples containing `key` and `token` attributes. Keys are used to lookup
data, while tokens are used to delete data. Tokens are generated from
`token generators`, similar to how keys are generated from `key generators`.

Making a Store
---------------

There are three built-in store types:

==============================  ========================
:class:`shorten.MemoryStore`    native Python.
:class:`shorten.MemcacheStore`  requires ``memcached`` or other Memcache server.
:class:`shorten.RedisStore`     requires a Redis server.
==============================  ========================

All stores are available at the module level and do not depend on any 3rd-party
Python libraries.

::

   import shorten
   from shorten import MemoryStore, MemcacheStore, RedisStore

A :class:`MemoryStore <MemoryStore>` does not have any dependencies, so it will
be used for the remaining examples.

Inserting Values
----------------

Use :meth:`insert` to insert values. A :class:`Pair` is returned, which can
destructured like a tuple.

::

   from shorten import MemoryStore

   store = MemoryStore()
   key, token = store.insert('aardvark')

   # 'aardvark'
   store[key]

   # True
   key in store

   pair = store.insert('bonobo')

   # Pair(key='0', token='0')
   print(pair)

Revoking Keys
-------------

After insertion, keys can be revoked, which will remove the key and its
value from the store.

::

   from shorten import MemoryStore

   store = MemoryStore()
   key, token = store.insert('aardvark')

   del store[token]

   # False
   key in store

Customizing Key Generation
--------------------------

A store's keys are generated with a :class:`KeyGenerator <KeyGenerator>`. 
The default key generators use a counter to increment keys, then convert that 
number to a string in an alphabet.

For example, hex keys can be generated by creating an iterable with the digits 
0 to 9 and the letters a to f, then passing it to the `alphabet` parameter:

::

   from shorten import MemoryStore

   hex_alphabet = '0123456789abcdef'
   store = MemoryStore(alphabet=hex_alphabet)

   # '0'
   # '1'
   # '2'
   # '3' 
   # '4'
   # '5'
   # '6'
   # '7'
   # '9'
   # 'a'
   for i in range(0, 10):
      pair = store.insert('aardvark')
      print(pair.key)

Alphabets can be any iterable, as long as each item is not contained within
any other item. For instance, ``('00', '0', '1')`` would be an ambiguous
alphabet, since ``00`` could be interpreted as two numbers.

Keys of a minimum length or starting at a certain *unencoded* value can be
generated by specifying `min_length` or `start`.


.. code:: python

   from shorten import MemoryStore
   
   emoticons = (':)', ':(', ':D', ';)', ';(', 'D:', ':o', ':\')
   emote_store = MemoryStore(alphabet=emoticons, start=12)

   key, token = emote_store.insert('aardvark')

   # ':(:D'
   key


Something

.. admonition:: Randomized Alphabets

   Shuffling your alphabet produces a random-looking key every time, but the
   order can easily be reconstructed from frequency counting and 
   `Benford's law <https://en.wikipedia.org/wiki/Benford's_law>`_.

   **Never** use short URLs to hide your data - use UUIDs or authentication
   instead.

Formatters
----------

A :class:`Formatter <Formatter>` is used to format the internal representation
of a  key or token. This is useful for Redis and SQL databases, which often 
need to prefix keys and columns in order to avoid clashes.

Any class or mixin with methods :meth:`format_token(self, token)` and 
:meth:`format_key(self, key)` can be used.

::

   import redis
   from shorten import RedisStore

   class Formatter(object):
      def __init__(self, namespace):
         self.ns = namespace

      def format_key(self, key):
         return '{ns}:keys:{key}'.format(ns=self.ns, key=key)

      def format_token(self, token):
         return '{ns}:tokens:{token}'.format(ns=self.ns, token=token)

   formatter = Formatter('testing')

   store = RedisStore(redis_client=redis, 
      counter_key = 'testing:counter_key',
      formatter=formatter,
      alphabet=hex_alphabet,
      start=255)
   
The returned key and token are not formatted, since formatting is
for intended for internal use.

::

   key, token = store.insert('aardvark')

   # 'ff'
   key

   # 'ff'
   token

   # 'aardvark'
   store['ff']

However, the value *is* inserted into Redis with a formatted key.

::

   # 'aardvark'
   redis.get('testing:keys:ff')

   # 'ff'
   redis.get('testing:tokens:ff')


