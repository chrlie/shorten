.. _introduction:

Introduction
============

Shorten is based around a :class:`dict`-like object called a `store`. 
Stores allow insertion, deletion and lookup of data through an interface similar to a Python :class:`dict`, the primary difference being that store `keys` 
are generated automatically by a `key generator` (or `keygen`).

The corresponding usage between a Python :class:`dict` and store is illustrated 
below:

==================================       ====================
store                                    dict
==================================       ====================
``key, token = store.insert(val)``       ``dict[key] = val``
``del store[token]``                     ``del dict[key]``
``key in store``                         ``key in dict``
``for key in iter(store)`` [#f1]_        ``for key in iter(dict)``
``store.has_token(token)``               no equivalent
``store.get_token(key)``                 no equivalent
``len(store)`` [#f1]_                    ``len(dict)``
==================================       ====================

.. [#f1] This functionality may be missing from some stores due to
         inefficiency or thread safety.

When data is inserted into a store a :class:`Pair <Pair>` is returned. Pairs 
are tuples containing `key` and `token` attributes. Keys are used to lookup
data, while tokens are used to delete data. Tokens are generated from
`token generators`, similar to how keys are generated from `key generators`.

Making a Store
---------------

There are three built-in store types:

==============================  ========================
:class:`shorten.MemoryStore`    native Python.
:class:`shorten.MemcacheStore`  requires ``memcached`` or other Memcache server.
:class:`shorten.RedisStore`     requires a Redis server.
==============================  ========================

All stores are available at the module level and do not depend on any 3rd-party
Python libraries.

::

   import shorten
   from shorten import MemoryStore, MemcacheStore, RedisStore

A :class:`MemoryStore <MemoryStore>` does not have any dependencies, so it will
be used for the remaining examples.

Inserting Values
----------------

Use :meth:`insert` to insert values. A :class:`Pair` is returned, which can
destructured like a tuple.

::

   from shorten import MemoryStore

   store = MemoryStore()
   key, token = store.insert('aardvark')

   # 'aardvark'
   store[key]

   # True
   key in store

   pair = store.insert('bonobo')

   # Pair(key='0', token='0')
   print(pair)

Revoking Keys
-------------

After insertion, keys can be revoked, which will remove the key and its
value from the store.

::

   from shorten import MemoryStore

   store = MemoryStore()
   key, token = store.insert('aardvark')

   del store[token]

   # False
   key in store

Customizing Key Generation
--------------------------

A store's keys are generated with a :class:`KeyGenerator <KeyGenerator>`. 
The default key generators use a counter to increment keys, then convert that 
number to a string in an `alphabet`.

.. admonition:: Randomized Alphabets

   You may notice that all the examples return keys that are clearly
   sequential and may choose to shuffle your alphabet to produce keys
   that look more random.
   
   Keep in mind that alphabet order can easily be reconstructed from frequency
   counting and `Benford's law <https://en.wikipedia.org/wiki/Benford's_law>`_,
   allowing someone to predict all future keys.

   **Never use short URLs to hide your data** - use UUIDs or authentication
   instead.

Alphabets can be anything that is indexable, as long as each symbol in the
alphabet is not contained within any other symbol.
For instance, ``('00', '0', '1')`` would be an ambiguous alphabet, since ``00`` could be interpreted as either the symbol ``00`` or two ``0`` symbols.

Keys of a minimum length or starting at a certain *unencoded* value can be
generated by specifying `min_length` or `start`. 

For example, hex keys can be generated:

::

   from shorten import MemoryStore

   hexabet = '0123456789abcdef'
   store = MemoryStore(alphabet=hexabet, min_length='2')

   # '10'
   # '11'
   # '12'
   for i in range(0, 2):
      pair = store.insert('aardvark')
      print(pair.key)


and more exotic alphabets can be constructed as well:

::

   from shorten import MemoryStore
   
   emoticons = (':)', ':(', ':D', ';)', ';(', 'D:', ':o', ':\')
   emote_store = MemoryStore(alphabet=emoticons, start=12)

   key, token = emote_store.insert('aardvark')

   # ':(:D'
   key


Customizing Token Generation
----------------------------

A token generator can be any object with a :meth:`create_token(key)` method.
Two classes are built-in: 

*  :class:`shorten.UUIDTokenGenerator <UUIDTokenGenerator>` produces
   UUID4 (essentially randomized) tokens ,
*  :class:`shorten.TokenGenerator <TokenGenerator>` returns the key itself.

See the examples for a more comprehensive token generator.

Formatters
----------

A :class:`Formatter <Formatter>` is used to format the internal representation
of a  key or token. This is useful for Redis and SQL databases, which often 
need to prefix keys and columns in order to avoid clashes.

Any class or mixin with methods :meth:`format_token(token)` and 
:meth:`format_key(key)` can be used.

Here's a formatter intended to namespace keys and tokens in Redis:

::

   import redis
   from shorten import RedisStore

   class Formatter(object):
      def __init__(self, namespace):
         self.ns = namespace

      def format_key(self, key):
         return '{ns}:keys:{key}'.format(ns=self.ns, key=key)

      def format_token(self, token):
         return '{ns}:tokens:{token}'.format(ns=self.ns, token=token)

   formatter = Formatter('testing')

   store = RedisStore(redis_client=redis, 
      counter_key = 'testing:counter_key',
      formatter=formatter,
      alphabet=hex_alphabet,
      start=255)
   
The returned key and token are not formatted, since formatting is intended 
for internal use.

::

   key, token = store.insert('aardvark')

   # 'ff'
   key

   # 'ff'
   token

   # 'aardvark'
   store['ff']

However, the value *is* inserted into Redis with a formatted key.

::

   # 'aardvark'
   redis.get('testing:keys:ff')

   # 'ff'
   redis.get('testing:tokens:ff')


